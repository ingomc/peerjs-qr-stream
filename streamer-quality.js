export function initStreamerApp() {
  console.log('üì± Multi-Device Streamer App mit Qualit√§tsstufen');
  const statusEl = document.getElementById('status');
  const localVideo = document.getElementById('local');
  const cameraSelect = document.getElementById('cameraSelect');
  const btnRefreshCameras = document.getElementById('btnRefreshCameras');
  const cameraStatus = document.getElementById('cameraStatus');
  const qualitySelect = document.getElementById('qualitySelect');
  const debugConsole = document.getElementById('debugConsole');
  const clearDebugBtn = document.getElementById('clearDebug');
  const viewerId = new URL(location.href).searchParams.get('id');
  document.getElementById('viewer').textContent = viewerId || '(fehlt)';

  let localStream;
  let reconnectAttempts = 0;
  const maxReconnectAttempts = 3;
  let peer;
  let selectedQuality = 'medium';

  // üêõ DEBUG CONSOLE
  function debugLog(message, type = 'info') {
    if (!debugConsole) return;
    
    const timestamp = new Date().toLocaleTimeString();
    const colors = {
      info: '#0f0',
      warn: '#ff0', 
      error: '#f00',
      success: '#0f0'
    };
    
    const logEntry = document.createElement('div');
    logEntry.style.color = colors[type] || '#0f0';
    logEntry.innerHTML = `[${timestamp}] ${message}`;
    
    debugConsole.appendChild(logEntry);
    debugConsole.scrollTop = debugConsole.scrollHeight;
    
    // Auch in normale Console
    console.log(`[DEBUG] ${message}`);
  }

  // Clear Debug Button
  if (clearDebugBtn) {
    clearDebugBtn.addEventListener('click', () => {
      if (debugConsole) debugConsole.innerHTML = '';
    });
  }

  // Startup Debug
  debugLog('üöÄ Streamer initialisiert');
  debugLog(`üì± Viewer-ID: ${viewerId || 'FEHLT!'}`);
  debugLog(`üåê User-Agent: ${navigator.userAgent.substring(0, 50)}...`);

  // üéØ QUALIT√ÑTSSTUFEN f√ºr Internet-Verbindungen
  const QUALITY_CONFIGS = {
    'ultra-low': {
      video: { width: 320, height: 240, frameRate: 15 },
      audio: { sampleRate: 16000, channelCount: 1 }
    },
    'low': {
      video: { width: 640, height: 480, frameRate: 20 },
      audio: { sampleRate: 22050, channelCount: 1 }
    },
    'medium': {
      video: { width: 1280, height: 720, frameRate: 25 },
      audio: { sampleRate: 44100, channelCount: 1 }
    },
    'high': {
      video: { width: 1920, height: 1080, frameRate: 30 },
      audio: { sampleRate: 48000, channelCount: 2 }
    }
  };

  // Quality Select Handler
  if (qualitySelect) {
    qualitySelect.addEventListener('change', () => {
      selectedQuality = qualitySelect.value;
      debugLog(`üéØ Qualit√§t ge√§ndert zu: ${selectedQuality}`);
      
      if (localStream) {
        debugLog('üîÑ Stream wird neu gestartet...');
        localStream.getTracks().forEach(track => track.stop());
        getCam();
      }
    });
  }

  // Internet-optimierter Peer mit TURN-Server
  function createPeer() {
    debugLog('üîß Erstelle Peer mit TURN-Server...', 'info');
    
    const config = {
      'iceServers': [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        {
          urls: [
            'turn:openrelay.metered.ca:80',
            'turn:openrelay.metered.ca:443',
            'turn:openrelay.metered.ca:443?transport=tcp'
          ],
          username: 'openrelayproject',
          credential: 'openrelayproject'
        },
        {
          urls: [
            'turn:relay1.expressturn.com:3478',
            'turn:relay1.expressturn.com:3478?transport=tcp'
          ],
          username: 'efSCKZqnZbF2RfHZ68',
          credential: 'web@anyfirewall.com'
        }
      ],
      'iceCandidatePoolSize': 30,
      'bundlePolicy': 'max-bundle',
      'rtcpMuxPolicy': 'require',
      'iceTransportPolicy': 'relay', // FORCIERE TURN-Server
      'sdpSemantics': 'unified-plan'
    };
    
    debugLog(`üåê ICE-Server Anzahl: ${config.iceServers.length}`);
    debugLog('‚ö° TURN-Server werden forciert (relay only)');
    
    return new Peer({ config });
  }

  async function getCam() {
    try {
      const config = QUALITY_CONFIGS[selectedQuality];
      debugLog(`üé• Starte Kamera: ${selectedQuality.toUpperCase()} (${config.video.width}x${config.video.height}@${config.video.frameRate}fps)`);
      statusEl.textContent = `Kamera wird geladen (${selectedQuality.toUpperCase()})...`;
      
      const constraints = {
        video: {
          width: { ideal: config.video.width },
          height: { ideal: config.video.height },
          frameRate: { ideal: config.video.frameRate },
          facingMode: { ideal: 'environment' }
        },
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: config.audio.sampleRate,
          channelCount: config.audio.channelCount
        }
      };

      debugLog('üìπ getUserMedia wird aufgerufen...');
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      
      const videoTrack = localStream.getVideoTracks()[0];
      const audioTrack = localStream.getAudioTracks()[0];
      const videoSettings = videoTrack.getSettings();
      const audioSettings = audioTrack.getSettings();
      
      debugLog(`‚úÖ Kamera OK: ${videoSettings.width}x${videoSettings.height}@${videoSettings.frameRate}fps`, 'success');
      debugLog(`üîä Audio: ${audioSettings.sampleRate}Hz, ${audioSettings.channelCount} Kan√§le`, 'success');
      
      localVideo.srcObject = localStream;
      statusEl.textContent = `Kamera bereit: ${selectedQuality.toUpperCase()} (${videoSettings.width}x${videoSettings.height}@${videoSettings.frameRate}fps)`;
      
    } catch (err) {
      debugLog(`‚ùå Kamera-Fehler: ${err.name} - ${err.message}`, 'error');
      statusEl.textContent = 'Kamera-Fehler: ' + err.message;
      
      // Fallback zu Ultra Low
      if (selectedQuality !== 'ultra-low') {
        debugLog('üîÑ Versuche Fallback zu Ultra Low...', 'warn');
        selectedQuality = 'ultra-low';
        qualitySelect.value = 'ultra-low';
        
        try {
          const ultraConfig = QUALITY_CONFIGS['ultra-low'];
          localStream = await navigator.mediaDevices.getUserMedia({
            video: {
              width: { ideal: ultraConfig.video.width },
              height: { ideal: ultraConfig.video.height },
              frameRate: { ideal: ultraConfig.video.frameRate },
              facingMode: { ideal: 'environment' }
            },
            audio: ultraConfig.audio
          });
          
          localVideo.srcObject = localStream;
          statusEl.textContent = `Fallback: ULTRA LOW aktiviert`;
          debugLog('‚úÖ Ultra Low Fallback erfolgreich', 'success');
          
        } catch (fallbackErr) {
          debugLog(`‚ùå Auch Fallback fehlgeschlagen: ${fallbackErr.message}`, 'error');
          statusEl.textContent = 'Kamera nicht verf√ºgbar';
        }
      }
    }
  }

  async function startConnection() {
    if (!viewerId) {
      debugLog('‚ùå Viewer-ID fehlt in URL!', 'error');
      alert('Viewer-ID fehlt (?id=...)');
      return;
    }
    
    debugLog(`üöÄ Starte Verbindung zu Viewer: ${viewerId}`);
    statusEl.textContent = 'Verbinde mit TURN-Server...';
    
    try {
      await getCam();
      
      debugLog('üîß Erstelle Peer-Verbindung...', 'info');
      peer = createPeer();
      
      peer.on('open', id => {
        debugLog(`‚úÖ Peer erfolgreich verbunden! ID: ${id}`, 'success');
        statusEl.textContent = 'Peer verbunden - starte Stream...';
        
        debugLog(`üìû Rufe Viewer an: ${viewerId}`);
        const call = peer.call(viewerId, localStream);
        
        // üí¨ DATA CHANNEL f√ºr Text-Nachrichten einrichten
        let dataChannel = null;
        
        if (call.peerConnection) {
          debugLog('üì® Erstelle DataChannel f√ºr Text-Nachrichten...');
          dataChannel = call.peerConnection.createDataChannel('messages', {
            ordered: true
          });
          
          dataChannel.addEventListener('open', () => {
            debugLog('‚úÖ DataChannel ist ge√∂ffnet - kann Nachrichten senden!');
            // Test-Nachricht an Viewer senden
            dataChannel.send('üì± Hallo vom Handy! DataChannel Test üöÄ');
            
            // Weitere Test-Nachrichten
            setTimeout(() => dataChannel.send('üì± 5 Sekunden Test-Nachricht'), 5000);
            setTimeout(() => dataChannel.send('üì± 10 Sekunden - funktioniert DataChannel?'), 10000);
          });
          
          dataChannel.addEventListener('message', (event) => {
            debugLog(`üí¨ Antwort vom Viewer: "${event.data}"`);
            // Weitere Antworten senden
            if (dataChannel.readyState === 'open') {
              dataChannel.send(`üì± Handy best√§tigt: DataChannel funktioniert! üëç`);
            }
          });
          
          dataChannel.addEventListener('error', (error) => {
            debugLog(`‚ùå DataChannel Fehler: ${error}`, 'error');
          });
          
          dataChannel.addEventListener('close', () => {
            debugLog('üì™ DataChannel geschlossen');
          });
        }
        
        call.on('stream', remoteStream => {
          debugLog('üì∫ Remote-Stream empfangen (ungew√∂hnlich f√ºr Streamer)', 'info');
        });

        call.on('close', () => {
          debugLog('üì¥ Call wurde beendet', 'warn');
          statusEl.textContent = 'Stream beendet';
        });

        call.on('error', err => {
          debugLog(`‚ùå Call-Fehler: ${err.type} - ${err.message}`, 'error');
          statusEl.textContent = 'Stream-Fehler: ' + err.message;
        });

        // ICE Connection State √ºberwachen - WICHTIG f√ºr TURN-Server Debug!
        if (call.peerConnection) {
          debugLog('üßä ICE Connection State Monitoring aktiviert');
          
          call.peerConnection.addEventListener('iceconnectionstatechange', () => {
            const state = call.peerConnection.iceConnectionState;
            debugLog(`üßä ICE State ge√§ndert zu: ${state}`, state === 'connected' ? 'success' : 'warn');
            
            if (state === 'connected') {
              statusEl.textContent = `‚úÖ Stream l√§uft √ºber TURN-Server! (${selectedQuality.toUpperCase()})`;
            } else if (state === 'disconnected') {
              statusEl.textContent = '‚ö†Ô∏è Verbindung unterbrochen...';
              debugLog('‚ö†Ô∏è ICE Verbindung unterbrochen - k√∂nnte TURN-Server Problem sein', 'warn');
            } else if (state === 'failed') {
              statusEl.textContent = '‚ùå Stream fehlgeschlagen';
              debugLog('‚ùå ICE Connection failed! TURN-Server nicht erreichbar oder √ºberlastet', 'error');
            } else if (state === 'checking') {
              debugLog('üîç ICE pr√ºft Verbindungsm√∂glichkeiten (TURN-Server werden getestet)...');
            } else if (state === 'new') {
              debugLog('üÜï ICE Connection initialisiert');
            }
          });

          // ICE Candidate Events - zeigt TURN-Server Aktivit√§t
          call.peerConnection.addEventListener('icecandidate', (event) => {
            if (event.candidate) {
              const candidate = event.candidate;
              debugLog(`üßä ICE Candidate: ${candidate.type} (${candidate.protocol}) - ${candidate.address || 'relay'}`);
              
              if (candidate.type === 'relay') {
                debugLog('üåê TURN-Server Relay Candidate gefunden!', 'success');
              }
            } else {
              debugLog('üßä ICE Gathering abgeschlossen');
            }
          });

          // Connection State (zus√§tzlich zu ICE State)
          call.peerConnection.addEventListener('connectionstatechange', () => {
            const state = call.peerConnection.connectionState;
            debugLog(`üîó Connection State: ${state}`);
          });
        }
      });

      peer.on('error', err => {
        debugLog(`‚ùå Peer-Fehler: ${err.type} - ${err.message}`, 'error');
        
        if (err.type === 'network') {
          debugLog('üåê Netzwerk-Fehler: M√∂glicherweise TURN-Server nicht erreichbar', 'error');
        } else if (err.type === 'peer-unavailable') {
          debugLog('üëª Viewer nicht erreichbar: ID existiert nicht oder offline', 'error');
        } else if (err.type === 'server-error') {
          debugLog('üñ•Ô∏è PeerJS Server-Fehler: Verbindung zur Signaling-Server fehlgeschlagen', 'error');
        }
        
        statusEl.textContent = 'Peer-Fehler: ' + err.message;
      });

      peer.on('disconnected', () => {
        debugLog('üîå Peer getrennt - versuche Reconnect...', 'warn');
        statusEl.textContent = 'Peer getrennt - Reconnect...';
      });
      
    } catch (err) {
      debugLog(`‚ùå Verbindungsfehler: ${err.message}`, 'error');
      statusEl.textContent = 'Verbindung fehlgeschlagen: ' + err.message;
    }
  }

  // Auto-Start
  if (viewerId) {
    const btnStart = document.getElementById('btnStart');
    if (btnStart) {
      btnStart.addEventListener('click', startConnection);
    }
    
    // Auto-start f√ºr QR-Code Links
    startConnection();
  } else {
    statusEl.textContent = 'Fehler: Viewer-ID fehlt in URL (?id=...)';
  }
}
