export function initStreamerApp() {
  console.log('üì± Multi-Device Streamer App (Hardware-Encoding optimiert)');
  const statusEl = document.getElementById('status');
  const localVideo = document.getElementById('local');
  const cameraSelect = document.getElementById('cameraSelect');
  const btnRefreshCameras = document.getElementById('btnRefreshCameras');
  const cameraStatus = document.getElementById('cameraStatus');
  const viewerId = new URL(location.href).searchParams.get('id');
  document.getElementById('viewer').textContent = viewerId || '(fehlt)';

  let localStream;
  let reconnectAttempts = 0;
  const maxReconnectAttempts = 3;
  let availableCameras = [];
  let selectedCameraId = null;

  // ÔøΩ DEVICE-DETECTION f√ºr optimale Einstellungen
  function detectDevice() {
    const userAgent = navigator.userAgent;
    if (userAgent.includes('iPhone')) {
      return { type: 'iPhone', icon: 'üçé', encoding: 'H264-Hardware' };
    } else if (userAgent.includes('Android')) {
      return { type: 'Android', icon: 'ü§ñ', encoding: 'H264-Hardware' };
    } else {
      return { type: 'Unknown', icon: 'üì±', encoding: 'Software' };
    }
  }

  const device = detectDevice();
  console.log(`${device.icon} Device erkannt: ${device.type} mit ${device.encoding}`);

  // üìπ UNIVERSAL KAMERA-AUSWAHL (alle Ger√§te)
  async function loadAvailableCameras() {
    cameraStatus.textContent = `üß™ Lade ${device.type} Kameras...`;
    cameraStatus.style.color = '#666';
    
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      availableCameras = devices.filter(device => device.kind === 'videoinput');
      
      // üîç Pr√ºfe ob Kamera-Labels verf√ºgbar sind (= Berechtigung vorhanden)
      const hasPermission = availableCameras.some(camera => camera.label && camera.label !== '');
      
      if (!hasPermission && availableCameras.length > 0) {
        console.log('‚ö†Ô∏è Kameras gefunden, aber keine Labels - Berechtigung fehlt');
        cameraStatus.textContent = `üîê ${availableCameras.length} Kameras gefunden - klicke "Neu laden" f√ºr Details`;
        cameraStatus.style.color = '#f57c00';
        
        cameraSelect.innerHTML = '<option value="auto">ü§ñ Automatisch (Berechtigung erforderlich)</option>';
        availableCameras.forEach((camera, i) => {
          cameraSelect.innerHTML += `<option value="${camera.deviceId}">üì∑ Kamera ${i + 1} (Berechtigung erforderlich)</option>`;
        });
        return;
      }
      
      console.log(`üì± ${availableCameras.length} ${device.type} Kameras gefunden:`, availableCameras);
      cameraStatus.textContent = `üîç ${availableCameras.length} Kameras gefunden, teste Hardware-Encoding...`;
      
      cameraSelect.innerHTML = '<option value="auto">ü§ñ Automatisch (R√ºckkamera bevorzugt)</option>';
      
      const workingCameras = [];
      
      for (let i = 0; i < availableCameras.length; i++) {
        const camera = availableCameras[i];
        const label = camera.label || `Kamera ${i + 1}`;
        
        cameraStatus.textContent = `üß™ Teste ${i + 1}/${availableCameras.length}: ${label}`;
        
        try {
          // Hardware-Test mit optimaler Aufl√∂sung f√ºr das Ger√§t
          const testStream = await navigator.mediaDevices.getUserMedia({
            video: { 
              deviceId: { exact: camera.deviceId },
              width: { ideal: 720, max: 1280 },    // Flexibler f√ºr verschiedene Ger√§te
              height: { ideal: 1280, max: 1920 }   // S25U kann mehr, iPhone XS weniger
            },
            audio: false
          });
          
          const videoTrack = testStream.getVideoTracks()[0];
          const settings = videoTrack.getSettings();
          testStream.getTracks().forEach(track => track.stop());
          
          console.log(`‚úÖ iPhone XS Kamera funktioniert: ${settings.width}x${settings.height}`);
          
          const icon = label.toLowerCase().includes('front') || label.toLowerCase().includes('user') ? 'ü§≥' : 'üì∑';
          let qualityBadge = '';
          const totalPixels = settings.width * settings.height;
          if (totalPixels >= 720*1280) qualityBadge = ' üèÜ';
          else if (totalPixels >= 540*960) qualityBadge = ' ‚≠ê';
          else qualityBadge = ' ‚úÖ';
          
          workingCameras.push({
            deviceId: camera.deviceId,
            label: label,
            icon: icon,
            resolution: `${settings.width}x${settings.height}`,
            qualityBadge: qualityBadge,
            pixels: totalPixels
          });
          
        } catch (testErr) {
          console.warn(`‚ùå iPhone XS Kamera nicht verf√ºgbar: ${label}`);
        }
      }
      
      workingCameras.sort((a, b) => b.pixels - a.pixels);
      
      workingCameras.forEach((camera) => {
        const option = document.createElement('option');
        option.value = camera.deviceId;
        option.textContent = `${camera.icon} ${camera.label} (${camera.resolution})${camera.qualityBadge}`;
        cameraSelect.appendChild(option);
      });
      
      if (workingCameras.length === 0) {
        cameraStatus.textContent = '‚ùå Keine iPhone XS Kameras funktionsf√§hig';
        cameraStatus.style.color = 'red';
      } else {
        cameraStatus.textContent = `‚úÖ ${workingCameras.length} iPhone XS Kameras bereit`;
        cameraStatus.style.color = 'green';
      }
      
    } catch (err) {
      console.error('‚ùå Fehler beim Laden der iPhone XS Kameras:', err);
      cameraStatus.textContent = `‚ùå Fehler: ${err.message}`;
      cameraStatus.style.color = 'red';
    }
  }

  cameraSelect.addEventListener('change', () => {
    selectedCameraId = cameraSelect.value === 'auto' ? null : cameraSelect.value;
    console.log('üì∑ iPhone XS Kamera gew√§hlt:', selectedCameraId || 'Automatisch');
    
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      getCam();
    }
  });

  btnRefreshCameras.addEventListener('click', async () => {
    try {
      cameraStatus.textContent = `üîê Fordere ${device.type} Kamera-Berechtigung an...`;
      cameraStatus.style.color = '#666';
      
      // üì± WICHTIG: Zuerst Kamera-Berechtigung anfordern
      const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
      console.log('‚úÖ Kamera-Berechtigung erhalten');
      
      // Temp-Stream sofort wieder stoppen
      tempStream.getTracks().forEach(track => track.stop());
      
      // Jetzt k√∂nnen wir alle Kameras richtig erkennen
      await loadAvailableCameras();
      
    } catch (error) {
      console.error('‚ùå Kamera-Berechtigung verweigert:', error);
      cameraStatus.textContent = `‚ùå ${device.type} Kamera-Berechtigung verweigert`;
      cameraStatus.style.color = '#d32f2f';
    }
  });

  async function getCam() {
    try {
      // üéØ NATIVE KAMERA-AUFL√ñSUNG verwenden (keine erzwungenen Constraints)
      const videoConstraints = {
        frameRate: { ideal: 30 }  // Nur Framerate optimieren, Rest nativ lassen
      };

      if (selectedCameraId) {
        videoConstraints.deviceId = { exact: selectedCameraId };
        console.log('üì∑ Verwende spezifische Kamera:', selectedCameraId);
      } else {
        videoConstraints.facingMode = { ideal: 'environment' };
        console.log('ü§ñ Automatische Kamera (R√ºckkamera bevorzugt)');
      }

      localStream = await navigator.mediaDevices.getUserMedia({ 
        video: videoConstraints, 
        audio: { 
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 48000,
          sampleSize: 16,
          channelCount: 2
        }
      });
      
      console.log(`${device.icon} ${device.type} Kamera aktiviert - verwendet native Aufl√∂sung!`);
      console.log('üìπ Native Video Settings:', localStream.getVideoTracks()[0].getSettings());
      
    } catch (err) {
      console.warn(`‚ö†Ô∏è ${device.type} Fallback wird verwendet:`, err.message);
      
      try {
        // üéØ Auch Fallback ohne erzwungene Aufl√∂sung
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            frameRate: { ideal: 30 }  // Nur Framerate, keine Aufl√∂sungs-Zwang
          }, 
          audio: { echoCancellation: true, sampleRate: 48000 }
        });
        console.log(`‚úÖ ${device.type} Fallback erfolgreich mit nativer Aufl√∂sung`);
      } catch (fallbackErr) {
        throw new Error(`${device.type} Kamera nicht verf√ºgbar: ` + fallbackErr.message);
      }
    }
    
    localVideo.srcObject = localStream;
    
    const videoTrack = localStream.getVideoTracks()[0];
    const settings = videoTrack.getSettings();
    
    console.log(`üé• ${device.type} Stream: ${settings.width}x${settings.height} @ ${settings.frameRate}fps`);
    console.log(`üìê Video wird automatisch per CSS angepasst - keine JavaScript-Manipulation n√∂tig!`);
  }

  function createPeer() {
    return new Peer({
      config: {
        'iceServers': [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          {
            urls: ['turn:openrelay.metered.ca:80', 'turn:openrelay.metered.ca:443'],
            username: 'openrelayproject',
            credential: 'openrelayproject'
          }
        ],
        'iceCandidatePoolSize': 10,
        'bundlePolicy': 'max-bundle',        // WLAN-optimiert
        'rtcpMuxPolicy': 'require',
        'sdpSemantics': 'unified-plan',
        'iceTransportPolicy': 'all'
      }
    });
  }

  async function startConnection() {
    if (!viewerId) { 
      alert('Viewer-ID fehlt (?id=...)'); 
      return; 
    }
    
    statusEl.textContent = 'Status: iPhone XS Kamera wird initialisiert‚Ä¶';
    
    try {
      await getCam();
      statusEl.textContent = 'Status: verbinde mit WLAN-optimiertem Streaming‚Ä¶';

      const peer = createPeer();
      
      peer.on('open', (id) => {
        console.log('üçé iPhone XS Peer verbunden:', id);
        
        const call = peer.call(viewerId, localStream);
        
        // üì± iPhone XS Hardware-Codec-Optimierung
        setTimeout(async () => {
          if (call.peerConnection) {
            const transceivers = call.peerConnection.getTransceivers();
            transceivers.forEach(async transceiver => {
              if (transceiver.sender && transceiver.sender.track && transceiver.sender.track.kind === 'video') {
                const params = transceiver.sender.getParameters();
                if (params.codecs) {
                  params.codecs = params.codecs.sort((a, b) => {
                    // H264 Hardware-Encoder f√ºr iPhone XS priorisieren
                    if (a.mimeType.includes('H264') && a.sdpFmtpLine?.includes('profile-level-id=42001f')) return -1;
                    if (b.mimeType.includes('H264') && b.sdpFmtpLine?.includes('profile-level-id=42001f')) return 1;
                    if (a.mimeType.includes('H264')) return -1;
                    if (b.mimeType.includes('H264')) return 1;
                    return 0;
                  });
                  console.log('üçé iPhone XS Hardware-Codecs:', params.codecs.map(c => c.mimeType));
                  await transceiver.sender.setParameters(params);
                }
              }
            });
            
            // WLAN-optimierte Bitrate
            setTimeout(async () => {
              const senders = call.peerConnection.getSenders();
              senders.forEach(async sender => {
                if (sender.track && sender.track.kind === 'video') {
                  const params = sender.getParameters();
                  
                  if (params.encodings && params.encodings.length > 0) {
                    const videoTrack = localStream.getVideoTracks()[0];
                    const settings = videoTrack.getSettings();
                    const pixels = settings.width * settings.height;
                    
                    let targetBitrate = pixels >= 720*1280 ? 8000000 : 6000000; // 8/6 Mbps WLAN
                    
                    params.encodings[0].maxBitrate = targetBitrate;
                    params.encodings[0].maxFramerate = 30;
                    params.encodings[0].priority = 'high';
                    
                    console.log(`üì∂ iPhone XS WLAN-Bitrate: ${targetBitrate/1000000} Mbps`);
                    await sender.setParameters(params);
                  }
                }
              });
            }, 1000);
          }
        }, 500);
        
        call.on('close', () => {
          statusEl.textContent = 'Status: iPhone XS Streaming beendet';
        });
        
        call.on('error', e => { 
          statusEl.textContent = 'iPhone XS Fehler: ' + e.type; 
        });

        statusEl.textContent = 'Status: iPhone XS Hardware-Streaming aktiv ‚úÖ';
      });
      
      peer.on('error', e => { 
        statusEl.textContent = 'iPhone XS Peer Fehler: ' + e.type; 
        console.error('iPhone XS Peer Fehler:', e);
        
        if (reconnectAttempts < maxReconnectAttempts) {
          reconnectAttempts++;
          setTimeout(() => {
            statusEl.textContent = `iPhone XS Reconnect ${reconnectAttempts}/${maxReconnectAttempts} üîÑ`;
            peer.destroy();
            startConnection();
          }, 3000);
        }
      });
      
    } catch (err) {
      statusEl.textContent = 'iPhone XS Kamera-Fehler: ' + err.message;
      console.error('iPhone XS Kamera-Fehler:', err);
    }
  }

  document.getElementById('btnStart').addEventListener('click', startConnection);
  
  // iPhone XS Kameras beim Start laden
  loadAvailableCameras();
}
